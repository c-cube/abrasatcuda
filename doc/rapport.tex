\documentclass{article}

\usepackage{listings}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{amssymb} % symboles mathématiques

\usepackage[french]{babel}
\usepackage[pdftex]{color}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fancybox}
\usepackage{verbatim}
\usepackage{lmodern}
\usepackage{hyperref}   % pour les urls


\lstset{
language=C,
keywordstyle=\bfseries\color[rgb]{0,0,1},
identifierstyle=\ttfamily,
commentstyle=\ttfamily\color[rgb]{0.133,0.545,0.133},
stringstyle=\ttfamily\color[rgb]{0.627,0.126,0.941},
showstringspaces=false,
basicstyle=\footnotesize,
numberstyle=\bfseries\footnotesize,
numbers=left,
stepnumber=0,
%numbersep=10pt,
tabsize=4,
breaklines=true,
breakatwhitespace=false,
%aboveskip={1.5\baselineskip},
columns=fixed,
extendedchars=true,
frame=single
}

% quelques commandes pratiques...
\newcommand{\commande}[1]{\fbox{\texttt{\$ #1}}}			% boite
\newcommand{\nbcommande}[1]{\texttt{\$ #1}}					% pas de boite
\newcommand{\multicommande}[1]{
	\framebox[\width]{
	\parbox{\textwidth}{#1}}}
\newcommand{\alert}[1]{\fbox{\textbf{#1}}}

\newcommand{\keyword}[1]{\textbf{\textcolor{blue}{#1}}}
\newcommand{\code}[1]{\texttt{\textcolor{green}{#1}}}
\newcommand{\cuda}{\textsc{CUDA}}


%-----------------------------------------------------
%----------------------------------------------------
%---------------------------------------------------



\author{Vincent Barrielle et Simon Cruanes}
\title{Rapport de projet : \textsc{SAT}-solver en \cuda}


\begin{document}

\maketitle
\tableofcontents%[pausesections] 
\newpage

\section{Introduction}
Ce projet vise à implémenter de manière efficace un \textsc{SAT}-solver de manière parallèle, plus particulièrement à l'aide de l'\textsc{API} \cuda de NVidia. Il est basé sur une méthode complète, c'est-à-dire parcourant exhaustivement l'arbre des possibilités d'affectations des variables, mais guidé par des heuristiques pour plus d'efficacité.

\section{Algorithme et implémentation efficace}
% description de l'algo et de son implémentation
% {{{
Nous nous sommes basés sur l'algorithme nommé \textsc{DPLL}, du nom de ses créateurs. Il s'agit d'un algorithme de \emph{backtracking} guidé par une heuristique dans le choix de la prochaine variable sur laquelle brancher. Malgré son grand âge, cette méthode reste très prisée grâce à la technique dite \emph{unit propagation}, qui, dans le cas de clauses de petites taille (ce qui est presque toujours le cas dans les instances difficiles), propage les nouvelles contraintes induites par une affectation de variable de manière très efficace. Ainsi, on se rend compte très rapidement si l'on se trouve dans une branche non satisfiable de l'arbre.\par

% algorithme de DPLL
\begin{algorithm}[h!]
\caption{algorithme de \textsc{DPLL}}\label{alg:DPLL}
\begin{algorithmic}
\REQUIRE F : une formule sous forme normal conjonctive
\ENSURE un booléen indiquant si la formule est satisfiable \\
\medskip
\textbf{function} DPLL( $F$ )
  \IF{$F = \emptyset $} 
    \RETURN "Satisfiable"
  \ENDIF
  \STATE $F \gets$ unitPropagation( $F$ )
  \IF{$\square \in F$}  
    \RETURN "not Satisfiable"
  \ENDIF
  \STATE $l \gets$ heuristic( $F$ ) \\
  \RETURN DPLL( $F \cup\{l\}$ ) $\vee$ DPLL( $F \cup \{\lnot l\}$ ) \\
\medskip
\textbf{function} unitPropagation( $F$ )\\
\WHILE{$\square \not\in F \land \exists $ unit clause $ l \in F$}
  Satisfy $l$ and Simplify $F$ \\
  \RETURN $F$
\ENDWHILE
\end{algorithmic}
\end{algorithm}


%}}}


\section{Implémentations parallèles}
% les différents parallélismes explorés et leur implémentation
%{{{

%}}}

\section{Performances comparées}
% benchmarking.
%{{{

%}}}

\section{Difficultés rencontrées}
% problèmes divers
%{{{
%}}}

\section{Répartition du travail}
% rôle de chacun
%{{{
%}}}


\section{Conclusion}

\end{document}


